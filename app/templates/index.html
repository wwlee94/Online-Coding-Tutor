<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Online Coding Tutor (OCT)</title>
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
  <!-- loading css -->
  <link rel="stylesheet" href="static/css/stairsloader.css">
  <link rel="stylesheet" href="static/css/bluespinnerloader.css">
  <link rel="stylesheet" href="static/css/loading.css">
  <link rel="stylesheet" href="static/css/loading-btn.css">


  <!-- Codemirror .css-->
  <link rel="stylesheet" href="static/css/codemirror.css">
  <link rel="stylesheet" href="static/css/darcula.css">
  <link rel="stylesheet" href="static/css/simplescrollbars.css">
  <link rel="stylesheet" href="static/css/show-hint.css">

  <!-- Alertify.js 알림 css -->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/alertifyjs@1.11.2/build/css/alertify.min.css" />
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/alertifyjs@1.11.2/build/css/themes/default.min.css" />

  <!-- 부트스트랩 -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">

  <style>
    /* 코드미러 설정 */
    .CodeMirror {
      border-top: 1px solid black;
      border-bottom: 1px solid black;
    }

    /*     .CodeMirror-gutter {
      padding: 5px;
    } */
    .breakpoints {
      padding: 10px;
    }

    .CodeMirror-linenumber {
      /*         color: #c8d2d7;
        font-size: 10px; */
      text-align: center;
      padding: 0 0 0 0;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background-color: #1E1F20;
      color: #ffffff;
      margin-top: 5px;
    }

    /* CSS */
    .tab {
      white-space: pre;
    }

    /* page-loader , debug-loader css 설정 */
    .h1-debug {
      font: 2em 'Roboto', sans-serif;
      margin-bottom: 40px;
      margin-left: -55px;
    }

    .debug-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      margin-top: -100px;
      margin-left: -10px;
    }

    .h1-page {
      font: 2em 'Roboto', sans-serif;
      margin-left: -50px;
      margin-bottom: -10px;
    }

    .page-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      margin-top: -120px;
      margin-left: -40px;
    }

    /* 부트스트랩 버튼 크기 */

    .form-control {
      position: relative;
      width: 120px;
    }

    .btn-fix {
      width: 80px;
      margin: 5px;
    }

    .ld-over-inverse {
      width: 500px;
      margin-right: 20px;
    }

    .ld-ring {
      padding: 8px;
    }

    .btn:focus,
    .btn:active {
      outline: none !important;
    }
  </style>
</head>

<body>
  <!-- loading class -->
  <div class="debug-loader" style="display:none;">
    <h1 class="h1-debug">Please wait :)</h1>
    <div id="loading"></div>
  </div>

  <!-- page loading -->
  <!-- <div class="page-loader" style="display:none;">
    <h1 class="h1-page">Page Loading ..</h1>
    <div class="loader">
      <div class="loader__bar"></div>
      <div class="loader__bar"></div>
      <div class="loader__bar"></div>
      <div class="loader__bar"></div>
      <div class="loader__bar"></div>
      <div class="loader__ball"></div>
    </div>
  </div> -->

  <!-- view 시작 -->
  <div class="container" style="display:none;">
    <!--       <a href="#" id="link" download="sample.json">download</a> -->
    <div class="row" style="margin-top:55px; margin-left:20px">
      <div class="col-md-6" style="margin-left:-50px">
        <p>
          Version
          <select class="form-control form-control-sm" name="version">
            <option>python 2.7</option>
            <option selected="selected">python 3.6</option>
          </select>
        </p>
        {% if content == 'false'%}
        <p>
          <div id="editor_loader" class="ld-over-inverse">
            <!-- 코드를 수정할 수 있는 코드미러 에디터 view -->
            <textarea id="editor"># -*- coding:utf-8 -*-&#10;&#10;# 메인함수&#10;if __name__ == '__main__':</textarea>
            <div class="ld ld-ring ld-spin"></div>
          </div>
        </p>
        {% else %}
        <p>
          <div id="editor_loader" class="ld-over-inverse">
            <!-- 코드를 수정할 수 있는 코드미러 에디터 view -->
            <textarea id="editor">{{content}}</textarea>
            <div class="ld ld-ring ld-spin"></div>
          </div>
        </p>
        {% endif %}
        <div>
          <button id="visualize" class="btn btn-primary btn-fix" type="button">Visualize</button>
          <button id="run" class="btn btn-success btn-fix" type="button">Run</button>
          <button id="debug" class="btn btn-warning btn-fix" type="button">Debug</button>
          <button id="stop" class="btn btn-danger btn-fix" type="button">Stop</button>
          <button id="example" class="btn btn-info btn-fix" type="button">Example</button>
        </div>
        <div id="viz_step" style="margin-top:10px">
          <div> <span style="color:#FFFFFF; font-size:x-large"> → </span> <span> 현재 실행된 라인 </span></div>
          <div> <span style="color:#30A9DE; font-size:x-large"> → </span> <span> 다음에 실행될 라인 </span></div>

          <br />
          <br />

          <div id="viz_step_view" style="display:none;">
            <button id="init_button" class="btn btn-primary" type="button">처음</button>&nbsp;
            <button id="pre_button" class="btn btn-primary" type="button">이전</button>&nbsp;
            <span>
              현재 단계 : <span id="current_step" style="font-size:large;"> </span> &nbsp; / &nbsp;
              마지막 단계 : <span id="last_step" style="font-size:large;"> </span> &nbsp;
            </span>
            <button id="next_button" class="btn btn-primary" type="button">다음</button>&nbsp;
            <button id="last_button" class="btn btn-primary" type="button">마지막</button>
          </div>
        </div>
      </div>

      <div class="col-md-6" style="margin-top:10px; margin-left:50px">
        <!-- 예제 뷰 -->
        <div id="example_view" toggle='1'>
          {% include 'example.html' %}
        </div>

        <!--  go.js를 이용한 visualizer -->
        <div id="myDiagramDiv" style="background-color: rgb(240,240,240); border: 1px solid black; width:580px; height:490px ; display:none;"></div>

        <br />
        <!-- 코드의 출력값을 볼수 있는 코드미러 view -->
        <div id="print_view" style="display:none;">
          <p style="color:white">출력 결과</p>
          <!--출력부분-->
          <textarea id="printer" style="background:#0E1628; color:#0E1628; background-color:#0E1628"></textarea>
        </div>

        <br />
        <!-- PDB 디버거 커맨드를 입력할 수 있는 코드미러 에디터 view -->
        <div id="pdb_view" style="display:none;">
          <p style="color:white">pdb 명령어</p>
          <textarea id="debug_input"></textarea>
        </div>

      </div>
      <!-- row -->

    </div>
    <!-- container -->
  </div>

    <!-- Jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

    <!-- Codemirror .js-->
    <script src="static/js/codemirror.js"></script>
    <script src="static/js/customCodemirror.js?ver=2"></script>
    <script src="static/js/python.js"></script>
    <script src="static/js/active-line.js"></script>
    <script src="static/js/simplescrollbars.js"></script>
    <script src="static/js/show-hint.js"></script>
    <script src="static/js/python-hint.js"></script>
    <script src="static/js/comment.js"></script>
    <script src="static/js/sublime.js"></script>

    <!-- Alertify.js 알림 js -->
    <!-- JavaScript -->
    <script src="//cdn.jsdelivr.net/npm/alertifyjs@1.11.2/build/alertify.min.js"></script>

    <!-- socket -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.6/socket.io.js"></script>

    <!-- go.js -->
    <script src="static/js/go.js"></script>
    <script src="static/js/go_init.js?ver=2"></script>

    <!-- inner script -->
    <script type="text/javascript" charset="utf-8">
      //visualize 정보
      var jsonArray = [];
      // 전역변수 생성 순서 저장
      var global_order = [];
      // 스택 생성 순서 저장
      var stack_order = [];
      // DICT 타입 생성 순서 저장
      var dict_order = [];
      //객체 생성 순서 저장 -> global_order가 가리키는 object key 순서대로 저장
      var object_order = [];
      // 함수 매개변수를 저장한 배열
      var stack_parameter = [];
      // 각각의 객체에 할당된 주소의 개수 저장 == 링크를 받는 개수
      var overlap = {};

      var stdout = "";

      // go.js 의 노드, 링크 리스트
      var nodeDataArray = []
      var linkDataArray = []

      //go.js node 색상 리스트
      var color_list = ["lightblue", "#4CAE4C", "#F0AD4E", "pink", "#5BC0DE", "lightcoral"]
      //color index
      var color_index = 0
      // Object(객체)들의 index Ex) List의 첫번째, 두번째 index
      var node_index = {};
      // 현재 객체가 어떤 타입인지 명시 Ex) "LIST", "DICT", "FUNCTION" ...
      var isNodeType = ""
      //subpanel의 개수 -> ObjectPanel안의 vertical한 패널 개수
      var panel_count = 0

      //go.js 변수 선언
      var $$ = go.GraphObject.make; // for conciseness in defining templates

      var myDiagram = $$(go.Diagram, "myDiagramDiv", // create a Diagram for the DIV HTML element
        {
          "undoManager.isEnabled": true, // enable undo & redo
          // initialScale: 0.8,
          // initialAutoScale: go.Diagram.Uniform, //개쩐다
          // initialDocumentSpot: go.Spot.Center,
          // initialViewportSpot: go.Spot.Center,
          "animationManager.duration": 300,
          //           "animationManager.isEnabled": false
          // allowHorizontalScroll: false,
          // allowVerticalScroll: false
        });
      // myDiagram.scale = 0.8;
      // myDiagram.minScale = 0.7;
      myDiagram.autoScale = go.Diagram.Uniform;
      myDiagram.contentAlignment = go.Spot.Center;
      myDiagram.scrollMode = go.Diagram.InfiniteScroll;
      myDiagram.isReadOnly = true; // 수정 불가

      // 사용자가 background 클릭하면 모든 하이라이트 제거
      myDiagram.click = function(e) {
        myDiagram.startTransaction("no highlighteds");
        myDiagram.clearHighlighteds();
        myDiagram.commitTransaction("no highlighteds");
      };

      // create the Overview and initialize it to show the main Diagram
      // var myOverview =
      //   $(go.Overview, "myOverviewDiv",
      //     { observed: diagram });

      /* 코드미러 설정 부분 */
      var editor = document.getElementById('editor');
      var cm_editor = CodeMirror.fromTextArea(editor, {
        mode: "python",
        keyMap: "sublime",
        lineNumbers: true,
        lineWrapping: true, //내용이 너무 길면 다음줄에 작성
        styleActiveLine: true, //포커스된 라인 색추가
        theme: "darcula",
        scrollbarStyle: "simple",
        extraKeys: { //키설정
          Tab: betterTab
          // "Tab": "autocomplete",
          // tab 수정 대신 indentUnit 수정함
          // "Tab": function(cm){
          //     cm.replaceSelection("  " , "end");
          //   }
        },
        val: editor.value,
        gutters: ["breakpoints", "CodeMirror-linenumbers"]
      });
      cm_editor.setSize(500, 380);
      //"inputRead" is the best event to show "auto completions" in "codemirror".
      //The only drawback is that you can't show hints on backspace or delete.
      cm_editor.on('inputRead', pythonHint); //자동완성 설정
      cm_editor.on("gutterClick", breakpoints); //클릭하면 breakpoints 설정
      var printer = document.getElementById('printer');
      var cm_printer = CodeMirror.fromTextArea(printer, {
        mode: "none",
        lineNumbers: true,
        lineWrapping: true,
        styleActiveLine: true,
        theme: "darcula",
        scrollbarStyle: "simple",
        readOnly: true, //printer이기 때문에 입력 제한한것
        val: printer.value
      });
      cm_printer.setSize(580, 150);
      var debug_input = document.getElementById('debug_input');
      var cm_debug = CodeMirror.fromTextArea(debug_input, {
        mode: "none",
        lineNumbers: true,
        theme: "darcula",
        scrollbarStyle: "simple",
        maxLength: 30, //최대 입력값 제한
        val: debug_input.value
      });
      cm_debug.setSize(580, cm_debug.defaultTextHeight() + 6 * 5);
      cm_debug.on("beforeChange", singleLine); //코드미러 입력라인 1줄로 제한
      cm_debug.on("beforeChange", maxLength); //최대 입력값 제한

      // $('.CodeMirror').resizable({
      //   resize: function() {
      //     cm_printer.setSize($(this).width(), $(this).height());
      //   }
      // });


      //       //codemirror text 정보 저장
      //       window.onbeforeunload = function() {
      //           console.log("새로고침")
      //           // 가져올 때
      //           name = sessionStorage.getItem('saved_name')
      //           cm_editor.setValue(name);
      //           console.log(name)
      //       };

      // 페이지 로딩 이후 작업
      $(document).ready(function() {

        //초기 페이지 로더 / print,pdb 코드미러 숨김
        pageLoader();

        //go.js
        init();

        //socketio 연결!!
        var socket = io.connect('http://localhost:5000');

        /* visualize 버튼 입력시 서버로 요청 보내는 이벤트 */
        $('#visualize').on('click', function(e) {

          showLoader();

          // 저장할 때  (또는 localStorage 사용)  // -> 브라우저에 값 저장
          sessionStorage.setItem('saved_name', cm_editor.getValue());
          console.log("editor text save");

          //결과창 초기화 및 view hide
          cm_printer.setValue("");
          //view 조정
          $("#print_view").show('slow');
          $("#pdb_view").hide('slow');
          $("#example_view").hide('fast');
          $("#myDiagramDiv").show('slow');
          $("#viz_step_view").show('slow');

          var version = $("select[name=version]").val();
          console.log(cm_editor.getValue());
          socket.emit('viz_request', {
            version: version,
            data: cm_editor.getValue()
          });

        });

        /* run 버튼 입력시 서버로 요청 보내는 이벤트 */
        $('#run').on('click', function(e) {
          //button loader 보이기
          showLoader();
          //결과창 초기화 및 view hide
          cm_printer.setValue("");
          //view 조정
          $("#print_view").show('slow');
          $("#pdb_view").hide('slow');
          $("#example_view").hide('fast');
          $('#myDiagramDiv').hide('slow');
          $("#viz_step_view").hide('slow');

          var version = $("select[name=version]").val();
          console.log(cm_editor.getValue());
          socket.emit('run_request', {
            version: version,
            data: cm_editor.getValue()
          });
        });

        /* debug 버튼 입력시 서버로 요청 보내는 이벤트 */
        $('#debug').on('click', function(e) {

          //결과창 초기화 및 view hide
          cm_printer.setValue("");

          showLoader();
          //debug는 응답 받으면 pdb_view 보여주기! 클릭시엔 항상 pdb_view는 숨김!
          //view 조정
          $("#print_view").show('slow');
          $("#pdb_view").hide('slow');
          $("#example_view").hide('fast');
          $('#myDiagramDiv').hide('slow');
          $("#viz_step_view").hide('slow');

          var version = $("select[name=version]").val();
          console.log(cm_editor.getValue());
          socket.emit('debug_request', {
            version: version,
            data: cm_editor.getValue()
          });
        });

        /* stop버튼 클릭시 이벤트 */
        $("#stop").on('click', function(e) {
          $("#print_view").hide('slow');
          $("#pdb_view").hide('slow');
          $("#example_view").hide('fast');
          $('#myDiagramDiv').hide('slow');
          $("#viz_step_view").hide('slow');

          socket.emit('stop_request', {
            data: "Stop Debugging!!"
          });
          //결과창 초기화
          cm_printer.setValue("");
          //editor breakpoint 제거
          cm_editor.clearGutter("breakpoints");
          //visaul 초기화
          myDiagram.clear();
        });

        // 트리거 파마리터 추가
        (function($) {
          $.each(['fadeIn', 'hide'], function(i, ev) {
            var el = $.fn[ev];
            $.fn[ev] = function() {
              this.trigger(ev);
              return el.apply(this, arguments);
            };
          });
        })(jQuery);

        // show, hide 트리거 이벤트
        $('#example_view').on('fadeIn', function() {
          $('#example_view').attr('toggle', '1')
        });

        $('#example_view').on('hide', function() {
          $('#example_view').attr('toggle', '0')
        });

        /* example버튼 클릭시 이벤트 */
        $("#example").on('click', function(e) {
          ex_toggle = $('#example_view').attr('toggle');
          if (ex_toggle == '0') {
            $('#example_view').fadeIn('slow');
          } else {
            $("#example_view").hide('fast');
          }
        });

        // example.html 의 link 클릭시 AJAX 이벤트
        $('.link').click(function() {

          url = "/example"
          type = "POST"

          bno = $(this).attr('value');
          content = $('#co' + bno).attr('value');
          data = {
            "bno": bno,
            "content": content
          };

          $.ajax({
            url: url,
            type: type,
            data: data,
            //complete 되면 reload
            complete: function(data) {
              console.log("Search Example file Success !!");
              cm_editor.setValue(data.responseJSON['content']);
            }
          });
        });

        /* PDB 명령어 입력시 서버로 요청 보내는 이벤트 */
        cm_debug.on('keydown', function(cm, event) {
          //엔터 입력시
          if (event.which == 13) {
            key = cm_debug.getValue();
            if (key == 'q' || key == 'quit') {
              //pdb_view 숨기기
              $("#pdb_view").hide('slow');
            }

            var version = $("select[name=version]").val();
            socket.emit('debug_input_request', {
              version: version,
              data: cm_debug.getValue()
            });

            //cm_debug - 커맨드 입력창 값 초기화
            cm_debug.setValue("");
          }
        });

        // 처음버튼
        $("#init_button").on('click', function(e) {
          step = 1;

          //breakpoint 초기화
          cm_editor.clearGutter("breakpoints");
          //breakpoint 설정
          linenum = jsonArray[0]['line'];
          setBreakPoint(linenum, "next")

          //printer 설정
          cm_printer.setValue("")
          cm_printer.setCursor(cm_printer.lineCount(), 0);

          //view 설정
          $("#current_step").text(step);

          //gojs 초기화
          myDiagram.clear();
          return false;
        });

        //visualize  이전 버튼 ##############################next만 잘 될 수도 있음 주의 할 것
        $("#pre_button").on('click', function(e) {
          step = parseInt($("#current_step").text()) - 1
          if (step <= 0) return;

          event = jsonArray[step - 1]['event'];
          globals = jsonArray[step - 1]['_globals'];
          stack_locals = jsonArray[step - 1]['stack_locals'];
          stdout = jsonArray[step - 1]['stdout'];


          //breakpoint 초기화
          cm_editor.clearGutter("breakpoints");
          //view 설정
          $("#current_step").text(step);

          //event의 동작에 따라 다르게 작동
          if (event == "step_line") {
            if (step >= 2) {
              linenum = parseInt(jsonArray[step - 2]['line'])
              setBreakPoint(linenum, "current")
            }
            if (linenum == parseInt(jsonArray[step - 1]['line'])) {
              cm_editor.clearGutter("breakpoints");
            }
            linenum = parseInt(jsonArray[step - 1]['line'])
            setBreakPoint(linenum, "next")
          } else if (event == "return" || event == "call") {
            //현재 위치 찍기
            linenum = parseInt(jsonArray[step - 1]['line'])
            setBreakPoint(linenum, "current")
          }

          //printer 설정
          cm_printer.setValue("")
          cm_printer.setValue(stdout);
          cm_printer.setCursor(cm_printer.lineCount(), 0);

          if (step == 1) {
            //gojs 초기화
            myDiagram.clear();
            return;
          }

          except_global_link = false
          // stack이 그려지면 global 링크들 모두 회색처리
          if (stack_locals.length != 0) except_global_link = true
          //Global, Object 시각화
          drawGlobalsObjectsNode(globals, except_global_link);

          //stack_locals 시각화 길이 0이면 안그림
          if (stack_locals.length != 0) {
            // 현재 진행 중인 스택 함수에(함수 이름 저장해서) focus 주기
            focus_link = stack_locals[0][0];
            console.log(focus_link);
            drawStackLocalsNode(stack_locals, focus_link);
          }

          myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
          //gojs 초기화
          myDiagram.requestUpdate();
          return false;
        });

        //visualize  다음 버튼
        $("#next_button").on('click', function(e) {

          step = parseInt($("#current_step").text())
          if (step == jsonArray.length) {
            //breakpoint 초기화
            cm_editor.clearGutter("breakpoints");
            return
          }

          event = jsonArray[step]['event']
          func_name = jsonArray[step]['func_name']
          func_name = func_name.replace(/<|>/g, "")
          globals = jsonArray[step]['_globals']
          stack_locals = jsonArray[step]['stack_locals']
          stdout = jsonArray[step]['stdout']

          //breakpoint 초기화
          cm_editor.clearGutter("breakpoints");
          //view 설정
          $("#current_step").text(step + 1)

          //event의 동작에 따라 breakpoint 다르게 작동
          if (event == "step_line") {
            if (step >= 1) {
              linenum = parseInt(jsonArray[step - 1]['line'])
              setBreakPoint(linenum, "current")

              //현재위치 == 다음위치라면 pass -> 두번 같은 곳 찍으면 없어져버림
              if (linenum == parseInt(jsonArray[step]['line'])) {
                cm_editor.clearGutter("breakpoints");
              }
            }
            linenum = parseInt(jsonArray[step]['line'])
            setBreakPoint(linenum, "next")
          } else if (event == "return" || event == "call") {
            //현재 위치 찍기
            linenum = parseInt(jsonArray[step]['line'])
            setBreakPoint(linenum, "current")
          }

          //printer 설정
          cm_printer.setValue("")
          cm_printer.setValue(stdout);
          cm_printer.setCursor(cm_printer.lineCount(), 0);

          except_global_link = false
          // stack이 그려지면 global 링크들 모두 회색처리
          if (stack_locals.length != 0) except_global_link = true
          //Global, Object 시각화
          drawGlobalsObjectsNode(globals, except_global_link);

          //stack_locals 시각화 길이 0이면 안그림
          if (stack_locals.length != 0) {
            focus_link = stack_locals[0][0];
            console.log(focus_link);
            drawStackLocalsNode(stack_locals, focus_link);
          }

          myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
          myDiagram.requestUpdate();
          //           myDiagram.currentCursor = "";
          return false;
        });
        // 마지막 버튼
        $("#last_button").on('click', function(e) {

          step = parseInt($("#last_step").text());

          globals = jsonArray[step - 1]['_globals'];
          stdout = jsonArray[step - 1]['stdout'];

          //breakpoint 초기화
          cm_editor.clearGutter("breakpoints");

          //view 설정
          $("#current_step").text(step);

          //마지막은 무조건 main의 return
          if (event == "return") {
            //현재 위치 찍기
            linenum = parseInt(jsonArray[step - 1]['line'])
            setBreakPoint(linenum, "current")
          }

          //printer 설정
          cm_printer.setValue("")
          cm_printer.setValue(stdout);
          cm_printer.setCursor(cm_printer.lineCount(), 0);

          //Global, object 시각화
          drawGlobalsObjectsNode(globals, false);
          //             //stack_locals 시각화
          //             drawStackLocalsNode(stack_locals);
          myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

          myDiagram.delayInitialization(); //애니메이션 딜레이 없앰
          myDiagram.requestUpdate();

          return false;
          //               var dataUri = "data:application/json;charset=utf-8,"+ encodeURIComponent(myDiagram.model.toJSON());
          //             var link = $("#link").attr("href", dataUri);

        });

        /* cm_editor (코드 수정 에디터) 수정시 pdb_view(pdb 명령어 입력창) 숨겨야 오류 방지 가능 */
        cm_editor.on('keydown', function(cm, event) {
          //클릭시 pdb_view 숨김
          $("#pdb_view").hide('slow');
          cm_debug.setValue("");
        });

        // 서버로 부터 respons 받는 작업
        //모든 response 감지하기 -> * 가 모든 response에 추가됨
        var onevent = socket.onevent;
        socket.onevent = function(packet) {
          var args = packet.data || [];
          onevent.call(this, packet); // original call
          packet.data = ["*"].concat(args);
          onevent.call(this, packet); // additional call to catch-all
        };

        //모든 response를 받으면 최소 2초동안 loader 숨기고 기본View 보여줌
        socket.on('*', function(msg) {
          //커서 위치 변경
          cm_printer.setCursor(cm_printer.lineCount(), 0);
          removeLoader();

          setTimeout(function() {
            console.log("Response * !!");
            hideLoader();
          }, 1100);
        });

        /* 최초 연결 시 서버로 connect 요청받음*/
        socket.on('after connect', function(msg) {
          var connect_string = 'new_connect';
          console.log(connect_string + " : ", msg);
        });

        /* 소켓 연결 해제시 */
        socket.on('disconnect', function(msg) {
          var disconnect_string = 'disconnect ';
          console.log(disconnect_string + " : ", msg);

          //결과창 초기화 및 view hide
          cm_printer.setValue("");
          $("#pdb_view").hide('slow');
          $("#print_view").hide('slow');
          $("#example_view").hide('fast');
          $("#myDiagramDiv").hide('slow');
          $("#viz_step_view").hide('slow');
        });

        /* visualize button 입력 시 서버로 viz 요청받음 */
        socket.on('viz_response', function(msg) {
          var viz_string = 'python visualize';
          console.log(viz_string + " : ", msg);
          // 나중엔 view hide로
          $("#current_step").text("")
          $("#last_step").text("")
          cm_editor.clearGutter("breakpoints");

          // File을 포함하면 컴파일 에러 문자 -> 따라서 오류가 아니면 정상적으로 진행
          if (msg['data'].includes('File')) {
            cm_printer.setValue(msg['data']);
            $("#myDiagramDiv").hide();
            $("#viz_step_view").hide();
          }
          else if(msg['data'].includes('exception_msg')){
            cm_printer.setValue(msg['data']);
            $("#myDiagramDiv").hide();
            $("#viz_step_view").hide();
          }
          // 기타 에러 + 200스탭 넘으면 에러처리
          else if (msg['data'].includes('uncaught_exception')) {
            temp = JSON.parse(msg['data']);
            jsonArray = temp[0]
            console.log(jsonArray)

            str = "";
            size = jsonArray.length - 1;
            exception = Object.keys(jsonArray[size]);
            for (var i = 0; i < exception.length; i++) {
              str += exception[i] + " : " + jsonArray[size][exception[i]] + "\n";
            }
            cm_printer.setValue(str);
            $("#myDiagramDiv").hide();
            $("#viz_step_view").hide();
          } else {
            temp = JSON.parse(msg['data']);
            jsonArray = temp[0]
            console.log(jsonArray);

            // global_order, stack_order 초기화 -> 전역변수 , 스택 순서대로 그리기 위함
            global_order = [];
            stack_order = [];
            dict_order = [];

            //stack_parameter 초기화
            stack_parameter = [];
            //stack 파라미터 정보 저장
            getFunctionParameter();

            // func 매개변수들 미리 stack_order에 추가!! ###################### 맞나?
            for (var i = 0; i < stack_parameter.length; i++) {
              obj = stack_parameter[i];
              name = Object.values(obj)[0]
              name = name.split('(')[1]
              name = name.split(')')[0]
              stack = name.split(',')

              for (var j = 0; j < stack.length; j++) {
                stack_order.push(stack[j]);
              }
            }
            // 받은 JSON 데이터 순환하며 순서 조정
            for (var i = 0; i < jsonArray.length; i++) {
              global_var = jsonArray[i]['_globals']
              //딕셔너리를 배열로 만들어줌
              global_key = Object.keys(global_var);
              for (var j = 0; j < global_key.length; j++) {
                key = global_key[j];
                // global 선언된 변수를 순서 차례로 저장하는것!
                if (!global_order.includes(key)) {
                  global_order.push(key);
                }

                // DICT 타입 생성 순서 저장
                // ex) global_var[key] = ["DICT",1,["key",value],["value",[1,2,3]]] -> "key가 먼저 생성"
                if (global_var[key] != undefined && global_var[key] != null) {
                  if (global_var[key].length >= 3) {
                    for (var k = 2; k < global_var[key].length; k++) {
                      if (global_var[key][0] == "DICT") {
                        dict = global_var[key][k];
                        if (!dict_order.includes(dict[0])) {
                          dict_order.push(dict[0]);
                        }
                      }
                    }
                  }
                }
              }
              stack = jsonArray[i]['stack_locals']
              //                 console.log("stack_key")
              //                 console.log(stack_key)
              //dict를 배열로 만들어줌
              for (var j = 0; j < stack.length; j++) {
                stack_key = Object.keys(stack[j][1]);
                for (var k = 0; k < stack_key.length; k++) {
                  // global 선언된 변수를 순서 차례로 저장하는것!
                  if (!stack_order.includes(stack_key[k])) {
                    stack_order.push(stack_key[k]);
                  }
                }
              }
            }
            console.log("global_order");
            console.log(global_order);
            console.log("stack_order")
            console.log(stack_order);
            console.log("dict_order");
            console.log(dict_order);

            //view 설정
            $("#current_step").text("1")
            $("#last_step").text("" + jsonArray.length)
            linenum = parseInt(jsonArray[0]['line'])
            setBreakPoint(linenum, "next")

            $("#myDiagramDiv").show();

            //gojs 초기화 -> *필요?*
            myDiagram.clear();

          } //else
        });

        /* run button 입력 시 서버로 run 요청받음 */
        socket.on('run_response', function(msg) {
          var run_string = 'python compile';
          console.log(run_string + " : ", msg);
          cm_printer.setValue(msg['data']);
        });

        /* debug button 입력 시 서버로 debug 요청받음 */
        socket.on('debug_response', function(msg) {
          var debug_string = 'python debug';
          console.log(debug_string + " : ", msg);
          //                 new_msg = cm_printer.getValue();
          //                 new_msg = new_msg + msg['data'];
          if (msg['success'] != null) {
            cm_printer.setValue(msg['success']);
            //linenum에 값이 존재한다면
            if (msg['linenum'] != '-1') {
              //breakpoint 초기화
              cm_editor.clearGutter("breakpoints");

              linenum = parseInt(msg['linenum']);
              console.log(linenum);

              setBreakPoint(linenum, "next")
            }
            $("#pdb_view").show('slow');
          }
          //debug 실패면
          else if (msg['fail'] != null) {
            cm_printer.setValue(msg['fail']);
            $("#pdb_view").hide('slow');
          }
        });

        /* debug_input 'enter' 입력 시 서버로 debug 요청받음 */
        socket.on('debug_input_response', function(msg) {
          var debug_string = 'python debug_input ';
          console.log(debug_string + " : ", msg);
          cm_printer.setValue(msg['data']);

          //linenum에 값이 존재한다면
          if (msg['linenum'] != '-1') {
            //breakpoint 초기화
            cm_editor.clearGutter("breakpoints");

            linenum = parseInt(msg['linenum']);
            console.log(linenum);

            setBreakPoint(linenum, "next")
          }
          //오류 시
          else {
            cm_editor.clearGutter("breakpoints");
          }
          // 재시작 된 상태면 alert
          if (msg['finish'] == '0') {
            alertify.message("Pdb Debugging Finished -!");
          } else if (msg['finish'] == '1') {
            //alertify.message("Pdb Debugging Restart -!");
            //오류 다시 시작하면 계속 알림뜸
          }
        });

        // 함수 모음
        //초기 페이지 로더
        function pageLoader() {
          $('.container').hide();
          // pink - ea4961 , blue - 137b85
          $('html').css({
            'background-color': '#137b85'
          });
          $('.debug-loader').fadeIn();
          cm_editor.focus();
          cm_editor.setCursor(cm_editor.lineCount(), 0);
        }

        //버튼 클릭할 때 - 버튼 로더 보여주기
        function showLoader() {
          var loader = $('#editor_loader');
          loader.addClass('running');
        }

        // loader 삭제
        function removeLoader() {
          var loader = $('#editor_loader');
          if (loader.hasClass('running')) loader.removeClass('running');
        }

        //응답 받을 때 - 로더 숨기기
        function hideLoader() {
          // 200 - fast / 600 - slow
          $('.container').fadeIn();
          $('.page-loader').fadeOut();
          $('.debug-loader').fadeOut();
          $('html').css({
            // 'background-color': 'rgb(28,28,28)'
            'background-color' : '#1E1F20'
          });
          cm_editor.refresh();
          cm_printer.refresh();
          cm_debug.refresh();

          myDiagram.delayInitialization();
          myDiagram.requestUpdate();
          //           myDiagram.rebuildParts();
          //           myDiagram.updateAllTargetBindings();
          //           myDiagram.computeBounds();
        }

        //em_editor 커서 , breakpoint 설정
        //type = next -  , current - 파랑
        function setBreakPoint(linenum, type) {
          if (linenum) {
            // 라인 번호에 따른 breakpoint 설정!
            var info = cm_editor.lineInfo(linenum - 1);
            cm_editor.setGutterMarker(linenum - 1, "breakpoints",
              info.gutterMarkers ? null : makeMarker(type));
            //커서 위치 변경
            cm_editor.setCursor(linenum - 1, 0);
          }
        }

        //global, object 그리는 함수
        //go.js 노드, 링크 데이터 채워 그리기 -> (global - 링크 - object) // 특정 위치에서
        function drawGlobalsObjectsNode(globals, except_link) {

          // 노드, 링크 초기화
          nodeDataArray = [];
          linkDataArray = [];
          // 색상 초기화
          color_index = 0;
          //subpanel의 개수(ObjectPanel안의 vertical한 패널 개수)를 다시 0으로 초기화
          panel_count = 0;

          console.log("current globals")
          console.log(globals)
          var globals_length = Object.keys(globals).length;
          // 전역변수 생성안되어 있으면 최상위 프레임인(프레임,전역변수,객체) 도 그리지 않음
          if (globals_length != 0 && globals_length != undefined) {
            //'프레임' frame 생성
            dict = {};
            dict["key"] = "프레임";
            dict["text"] = "프레임";
            dict["color"] = "transparent";
            dict["isGroup"] = true;
            nodeDataArray.push(dict);

            //'전역변수' frame 생성
            dict = {}
            dict["key"] = "전역변수";
            dict["text"] = "전역변수";
            dict["color"] = "black";
            dict["isGroup"] = true;
            dict["group"] = "프레임";
            nodeDataArray.push(dict);
          }
          // 임시 globalNode   -> {x: [1,2,3]} -> "x"
          tempGlobalNode = [];
          // // 임시 Objectframe ->  {x : [1,2,3]} -> "[]"
          tempObjectFrame = [];
          // 임시 subPanelFrame -> layer 나누기 위함 (잘 출력하려고)
          tempSubPanelFrame = [];
          // 임시 objectNode -> {x: [1,2,3]} -> "1,2,3"
          tempObjectNode = [];
          // 임시 linkData
          tempLinkData = [];
          // object들의 주소를 담은 배열 -> 중복 검사하기위해
          object_ref = [];
          // object의 생성 순서
          object_order = [];
          //dict 생성
          dict_ref = [];

          //각 global변수(compound 타입 일경우) 처음 가리키는 주소 담은 배열 -> (linkedList 그릴때 layer 나누려고?)
          global_first_ref = [];
          global_order.forEach(function(key) {
            if (!isPrimitive(globals[key])) global_first_ref.push(globals[key][1]);
          });
          console.log("global_first_ref");
          console.log(global_first_ref);

          //위의 global_first_ref를 참조할 index
          global_index = 0;
          // 모든 경우에 globals 변수 검사 -> {x:[~~],:"~~", ...}
          //global_order의 변수 순서대로 for문 돌며 검사  ************************* 얘 덕분에 순서대로 해결
          global_order.forEach(function(key) {
            // 맞는 키를 가지고 있다면
            if (globals.hasOwnProperty(key)) {
              if (isPrimitive(globals[key])) {

                global = {};
                global["key"] = "" + key;
                global["text"] = key + " = " + globals[key];
                global["color"] = color_list[color_index % color_list.length];
                global["group"] = "전역변수";
                color_index++;
                tempGlobalNode.push(global);
              } else {
                //전역 변수 x
                global = {}
                global["key"] = "" + key;
                global["text"] = key;
                global["color"] = color_list[color_index % color_list.length];
                global["group"] = "전역변수";
                color_index++;
                tempGlobalNode.push(global);

                //전역 객체-> 변수 x가 가르키는 주소
                object = {}
                object["key"] = "" + globals[key][1]
                // 내부 데이터는 아래에서

                //전역 - 객체 링크
                link = {}
                link["from"] = global["key"];
                link["to"] = object["key"];
                //stack을 그리면 link 색상 변경
                if (except_link) link["color"] = "grey";
                linkDataArray.push(link);

                // 이미 만들어져 있는 object 가 있다면 객체 생성 X ->  global과 링크만 연결하면 됨
                // (x = [1,2,3] , y = x)인 경우에 해당되지
                if (!object_ref.includes(object["key"])) {
                  object_panel = {}
                  object_panel["key"] = "panel_" + key;
                  object_panel["group"] = "객체";
                  object_panel["isGroup"] = true;
                  object_panel["category"] = "object_panel";
                  // if(globals[key][0] == "DICT") object_panel["column"] = "2";
                  nodeDataArray.push(object_panel);

                  //recursive draw
                  //재귀로 반복하면서 전역변수 객체변수 생성
                  // 데이터 값(primitive or compound) , group_key(재귀로 돌면서 자기 위 부모 참조) , 기준이 될 panel(루트 그룹), 첫 생성인지 아닌지 여부
                  decode_type(globals[key], object_panel["key"], object_panel["key"], true);

                  global_index++;
                } //if
              }
            } // hasOwnProperty
          });

          //dict 내 key, value 순서
          console.log("dict_ref");
          console.log(dict_ref);
          //전체 object 주소들 저장
          console.log("object_ref");
          console.log(object_ref);

          //############################# *link, node 순서 바꾸는 작업 필요?*
          overlap = {}
          //object가 받는 링크의 개수 체크 -> 링크 2개를 받고 재귀로 생성되지 않는 애는 나중에 그림
          for (var i = 0; i < linkDataArray.length; i++) {
            overlap_key = "" + linkDataArray[i]["to"]
            if (!overlap.hasOwnProperty(overlap_key)) {
              overlap[overlap_key] = 1
            } else {
              overlap[overlap_key] += 1
            }
          }

          //중복된 주소 체크
          console.log(overlap);

          // 그리는 순서 정리하기 !!
          // *중요 1. global 생성 순서대로 nodeDataArray 정렬 2. global 생성 순서대로 object,linkDataArray 재 정렬
          // 호출된 global 변수 순서대로 저장 -> 순서는 global_order에 저장해둠
          for (var i = 0; i < global_order.length; i++) {
            //1.
            for (var j = 0; j < tempGlobalNode.length; j++) {
              // 순서에 해당하는 Node가 존재한다면 먼저 넣음
              if (global_order[i] == tempGlobalNode[j]['key']) {
                nodeDataArray.push(tempGlobalNode[j]);
              }
            }

            // 전역변수가 첫번째로 가르키는 주소만 미리 추가 후 아래 2.에서 사용
            // ex) from : "x" , to : "1" ...
            for (var j = 0; j < linkDataArray.length; j++) {
              //(1) 포인터가 아닐때 -> ex) x,y,i 등등
              if (global_order[i] == linkDataArray[j]["from"]) {
                link_to = linkDataArray[j]["to"]; // global 변수가 가르키는 목적지 key
                if (!object_order.includes(link_to)) object_order.push(link_to);
              }
            }

            //2.
            // global 변수가 포인팅하는 object 따로 저장 -> linkedList 잘 표현하기 위해서
            for (var j = 0; j < linkDataArray.length; j++) {

              //(2) 포인터가 있다면 검사 -> p들어가면 포인터
              if (linkDataArray[j]["from"].includes('p')) {
                //p_()_?? -> () 이 부분만 가져옴
                check = linkDataArray[j]["from"].split("_")[1]

                // 지금까지 link 탄 모든 주소 저장해둔거 다시 확인해서 돔
                //#################################but 지금 비효율 앞에있는 인덱스는 불필요하게 계속 돔
                for (var z = 0; z < object_order.length; z++) {
                  tmp_link = object_order[z];
                  // check(from)와 이전 link (to)같으면 해당 인덱스의 "to" 부분 추가
                  if (tmp_link == check) {
                    link_to = linkDataArray[j]["to"]; // 다음 링크
                    //차이가 1이라면 추가 아니면 재귀로 생성된게 아니기 때문에 그냥 pass!
                    if (Math.abs(parseInt(tmp_link) - parseInt(link_to)) != 1 && overlap[link_to] >= 2) { // ####얘도 좀 불안
                      // overlap[link_to]-=1 // 한번 지나쳤으니 -1
                      continue
                    } else {
                      if (!object_order.includes(link_to)) object_order.push(link_to);
                      overlap[link_to] -= 1 // 한번 지나쳤으니 -1
                    }
                  }
                }
              }
            }
          }

          console.log("object_order");
          console.log(object_order);

          console.log("tempGlobalNode");
          console.log(tempGlobalNode);

          console.log("tempObjectFrame");
          console.log(tempObjectFrame);

          console.log("tempSubPanelFrame");
          console.log(tempSubPanelFrame);

          console.log("tempObjectNode");
          console.log(tempObjectNode);

          // ObjectFrame이 비었으면 '객체' Frame 생성 X
          if (tempObjectFrame.length != 0) {
            //Object frame 생성
            dict = {}
            dict["key"] = "객체";
            dict["text"] = "객체";
            dict["color"] = "transparent";
            dict["isGroup"] = true;
            // dict["category"] = "dict";
            nodeDataArray.push(dict);

            // 1. object_order 순서대로 '객체' frame(틀) 먼저 저장
            for (var i = 0; i < object_order.length; i++) {
              //순서대로 저장
              for (var j = 0; j < tempObjectFrame.length; j++) {
                if (object_order[i] == tempObjectFrame[j]['key']) {
                  nodeDataArray.push(tempObjectFrame[j]);
                }
              }
            }
            // 2. subPanel 저장하기
            // 2-1. 필요 없는 subPanel 빼기
            // -> nodeDataArray를 돌면서 추가된 subpanel 중에서 subpanel를 참조하는 노드가 없다면 안쓰는 subpanel이니 해당 subpanel 빼고 추가
            // LinkedList 링크 체인지에서 나타나는 버그 해결
            for (var i = 0; i < tempSubPanelFrame.length; i++) {
              for (var j = 0; j < nodeDataArray.length; j++) {
                //패널 키 -> Ex) subPanel_LIST_No1_from_5
                var panel_key = tempSubPanelFrame[i]["key"];
                var group_key = nodeDataArray[j]["group"];
                // group_key 가 panel_key와 일치하지 않으면 필요 없는 subPanel 객체
                if (panel_key === group_key) {
                  nodeDataArray.push(tempSubPanelFrame[i]);
                }
              }
            }
            // *DICT를 표현할때 선언 순서에 맞게, 또 올바르게 표현하기 위한 작업*
            // #point_1에서 dict_order 순서대로 저장 후 point_2에서 저장하지 않은 나머지 저장하기 위한 리스트
            dict_token = []
            // #point_1 - dict_order 순서대로 저장
            for (var i = 0; i < dict_order.length; i++) {
              for (var j = 0; j < tempObjectNode.length; j++) {
                // subdict부분만 조정하면 됨
                if (tempObjectNode[j]['category'] == "subdict") {
                  token = tempObjectNode[j]['key'].split("_")[1] // dict_order와 비교할것 추출
                  if (token == dict_order[i]) {
                    dict_token.push(tempObjectNode[j]['key']);
                    nodeDataArray.push(tempObjectNode[j]);
                  }
                }
              }
            }

            // #point_2
            //나머지 위에서 검사하지 않은 tempObject -> nodeDataArray에 저장 ############################################## 주의
            for (var j = 0; j < tempObjectNode.length; j++) {
              if (!object_order.includes(tempObjectNode[j]['key']) && !dict_token.includes(tempObjectNode[j]['key'])) {
                nodeDataArray.push(tempObjectNode[j]);
              }
            }
          }
          console.log("nodeDataArray")
          console.log(nodeDataArray)
          console.log("linkDataArray")
          console.log(linkDataArray)
        }

        //stack 변수 그리는 함수
        //stack 그리기 -> 특정 위치에서 line 1 , line 10 위치 등등
        function drawStackLocalsNode(stack_locals, focus_link) {
          console.log("stack_locals");
          console.log(stack_locals);

          // drawglobals에도 있는 변수들임 -  무조건 같은 이름 써야함
          // 임시 globalNode
          //             tempGlobalNode = [];
          // 임시 objectNode
          tempObjectNode = [];
          // 임시 stackNode
          tempStackNode = [];
          //stack_group_key
          stack_group_key = [];

          //함수 이름
          for (var i = 0; i < stack_locals.length; i++) {
            func_name = stack_locals[i][0] //함수이름

            //func stack 틀생성
            dict = {};
            dict["key"] = "stack_" + func_name + "_" + (i + 1);
            dict["text"] = func_name;
            dict["color"] = "black";
            dict["group"] = "프레임"
            dict["isGroup"] = true;
            tempStackNode.push(dict);

            //stack_locals의 크기 만큼 dict를 생성하니 group_key 저장해둠
            stack_group_key.push(dict["key"]);
          }

          // 생성순서 거꾸로 먼저 추가해줌 -> 최근것이 올라오도록
          for (var i = tempStackNode.length - 1; i >= 0; i--) nodeDataArray.push(tempStackNode[i]);

          empty_stack = [] // 비어있는 스택들 함수 이름 저장
          //stack 생성 순서대로 검사 ######################그림 그린 변수는 다음 함수처리 속도 향상을 위해 지우는 방안?
          for (var i = 0; i < stack_order.length; i++) {
            // 여러가지 스택 함수들 검사
            for (var j = 0; j < stack_locals.length; j++) {
              stack_variable = stack_locals[j];
              if (Object.keys(stack_variable[1]).length ===0){
                // 한번만 empty 출력
                if(!empty_stack.includes(stack_variable[0])) {
                  emptyObject = {}
                  emptyObject["key"] = "empty_" + stack_variable[0];
                  emptyObject["text"] = "Stack";
                  emptyObject["color"] = "transparent";
                  emptyObject["stroke"] = "transparent";
                  emptyObject["group"] = "" + stack_group_key[j];
                  nodeDataArray.push(emptyObject)

                  empty_stack.push(stack_variable[0])
                }
              }
              else{
              //stack_variable[0] -> 함수 이름 / stack_variable[1] -> 스택 변수들
              // 각각의 함수들 중 stack_order(stack 변수 생성 순서)값을 포함하고 있다면 추가
              if (stack_variable[1].hasOwnProperty(stack_order[i])) {
                func_name = stack_variable[0];
                key = stack_order[i];
                value = stack_variable[1][stack_order[i]];

                //func 함수의 stack 변수 생성
                if (isPrimitive(value)) {
                  stack_global = {};
                  if (key == "__return__") stack_global["text"] = "return = " + value;
                  else stack_global["text"] = key + " = " + value;

                  stack_global["key"] = "stack_" + key + (j + 1);
                  stack_global["color"] = color_list[color_index % color_list.length];
                  stack_global["group"] = stack_group_key[j];
                  color_index++;
                  nodeDataArray.push(stack_global);
                } else {
                  //스택 변수 h
                  stack_global = {}
                  stack_global["key"] = "stack_" + key + (j + 1);
                  stack_global["text"] = key;
                  stack_global["color"] = color_list[color_index % color_list.length];
                  stack_global["group"] = stack_group_key[j];
                  color_index++;
                  nodeDataArray.push(stack_global);

                  //스택 객체-> 변수 h가 가르키는 주소
                  stack_object = {}
                  stack_object["key"] = "" + value[1]
                  // 내부 데이터는 아래에서

                  //스택 - 객체 링크
                  link = {}
                  link["from"] = stack_global["key"];
                  link["to"] = stack_object["key"];
                  if (focus_link != func_name) link["color"] = "grey"
                  linkDataArray.push(link);

                  // 이미 만들어져 있는 object 가 있다면 객체 생성 X ->  global과 링크만 연결하면 됨
                  //  (x = [1,2,3] , y = x)인 경우에 해당되지
                  if (!object_ref.includes(stack_object["key"])) {

                    //recursive draw
                    // 전체 globals data , key의 주소
                    //재귀로 반복하면서 전역 객체 생성
                    decode_type(value, "스택", "객체", true);

                  } //if
                } //else
              } //hasOwnProperty
            }
            } //stack_locals
          }



          // Object가 비었으면 Objectframe 생성 X
          if (tempObjectNode.length != 0) {
            //                 //Object frame 생성
            //                   dict = {}
            //                   dict["key"] = "스택";
            //                   dict["text"] = "스택";
            //                   dict["color"] = "black"
            //                   dict["isGroup"] = true;
            //                   dict["category"] = "object";
            //                   nodeDataArray.push(dict);
            //                 // object_order 순서대로 먼저 저장 ##################### stack에서도 순서대로 저장하는 로직이 필요?
            //                 for(var i=0;i<object_order.length;i++){
            //                      for(var j=0;j<tempObjectNode.length;j++){
            //                             if(object_order[i] == tempObjectNode[j]['key']){
            //                                 nodeDataArray.push(tempObjectNode[j]);
            //                             }
            //                      }
            //                 }
            for (var j = 0; j < tempObjectNode.length; j++) {
              if (!stack_order.includes(tempObjectNode[j]['key'])) {
                nodeDataArray.push(tempObjectNode[j]);
              }
            }

          } // != 0
        }

        // 함수 파라미터 가져오기 -> func(a,b,c)
        function getFunctionParameter() {
          check_overlap = [];
          for (var i = 0; i < jsonArray.length; i++) {
            event = jsonArray[i]['event']
            if (event == "call") {
              def_line = jsonArray[i]['line']
              func_name = jsonArray[i]['func_name']

              //중복 확인 안 넣었으면 넣어줌
              if (!check_overlap.includes(func_name)) {
                check_overlap.push(func_name);
                code = cm_editor.getLine(def_line - 1);
                code = code.replace('def ', "");
                code = code.replace(':', "");
                code = code.replace(/(\s*)/g, "")

                dict = {}
                dict[func_name] = code
                stack_parameter.push(dict);
              }
            }
          }
          console.log("stack_parameter")
          console.log(stack_parameter)

        }

        // 라인 별 json 데이터 파싱
        // state = true -> 처음 생성 객체
        // state = false -> recursive로 생성된 객체
        // data - 표현할 데이터, group_key 바로 위 부모객체, root_group - 최상위 부모객체, state
        function decode_type(data, group_key, root_group, state) {

          // 프리미티브이면 생성
          if (isPrimitive(data)) {
            var tmpData = "";
            //primitive 객체 생성
            subObject = {}

            //문자열로 되어있으면 '' 추가
            if (typeof(data) === typeof("")) tmpData = "'" + data + "'";
            //python에선 null -> None으로 표현
            else if (data == null) tmpData = "None";
            else tmpData = data;

            //DICT 타입이면 -> decode_type 함수를 (type == DICT)에서 호출한 경우
            if (isNodeType === "DICT") {
              text = tmpData + " : ";
              data = ""
            }
            //Function 타입이면
            else if(isNodeType === "FUNCTION"){
              // FUNCTION은 '' 빼려고 data 대입
              text = "" + data
            }
            else {
              text = "" + tmpData

              //head 선언
              subObject["index"] = node_index[group_key]++;

              console.log("group_key")
              console.log(group_key)
              console.log("node_index")
              console.log(node_index)
              subObject["category"] = "objectNode";
            }

            //subObject 세부 설정
            subObject["key"] = "data_" + group_key + "_" + data;
            subObject["text"] = text
            subObject["color"] = color_list[++color_index % color_list.length];
            subObject["group"] = "" + group_key;

            tempObjectNode.push(subObject);
            return;
          } else {
            // data[0] -> 타입 | data[1] -> 주소
            //포인터 객체
            tmpObject = {};
            tmpObject["key"] = "p_" + group_key + "_" + data[1];

            //포인터 받는 객체
            subObject = {};
            subObject["key"] = "" + data[1];

            //포인터-> 객체로 링크 연결해줌 -> state=true 인경우 -> decode_type() 첫 선언시 -> 링크 안검 -> 객체 생성만
            if (!state) {
              tmpObject["text"] = "*";
              tmpObject["color"] = color_list[color_index % color_list.length];
              tmpObject["group"] = "" + group_key;

              if (isNodeType !== "DICT") {
                //head 선언
                tmpObject["index"] = node_index[group_key]++;
                tmpObject["category"] = "objectNode";
              }
              tempObjectNode.push(tmpObject);

              //전역 - 객체 링크
              link = {}
              link["from"] = tmpObject["key"];
              link["to"] = subObject["key"];
              linkDataArray.push(link);
            }
            // 전역변수에서 decode_type 첫 생성시
            else {
              //data 길이가 2이면 [],(),{} 비어있는 리스트이므로 Empty 이벤트 추가
              if (data.length == 2) {
                emptyObject = {}
                emptyObject["key"] = "empty_" + data[1];
                emptyObject["text"] = "Empty";
                emptyObject["color"] = "transparent";
                emptyObject["stroke"] = "transparent";
                emptyObject["group"] = "" + data[1];
                tempObjectNode.push(emptyObject);
              }
            }

            // linkedList구조에서 link 조작시 panel 별로 잘 매칭할 수 있도록
            // 즉, 전역변수가 한번 링크해서 들어가는 모든 노드들은 같은 panel에 매칭
            // 첫 링크 정보 - global_first_ref
            if (object_ref.length >= 1) {
              // console.log("마지막 object_ref");
              // console.log(parseInt(object_ref[object_ref.length-1]));
              // console.log("현재 주소");
              // console.log(parseInt(data[1]));

              // 마지막 object_ref 와 현재 주소(data[1]) 값의 차이가 1이 아니고
              // 담아둔 첫 링크와 현재주소가 같으면 새로운 패널 생성 , 아니면 패스! 더 그리지 않는다
              if (Math.abs(parseInt(object_ref[object_ref.length - 1]) - parseInt(data[1])) != 1) {
                if (global_first_ref[global_index] != data[1]) {
                  console.log("패스해야할 부분 (더 그리지 않음)");
                  return;
                }
              }
            }

            //이미 도착 주소가 할당되어 있는 객체는 만들필요? X -> 바로 위에서 설정한 포인터만 이어주면 됨!
            if (!object_ref.includes(subObject["key"])) {
              object_ref.push(subObject["key"]);
              node_index[subObject["key"]] = 0;

              // 객체 생성 2단계
              //1. compound 타입인게 확정났으니 그룹 ('LIST','DICT' 등등) 하나 만들어줘야함!
              subObject["text"] = "" + data[0];
              subObject["group"] = "" + root_group;
              subObject["isGroup"] = true
              if (data[0] != "DICT") subObject["category"] = "object";
              else subObject["category"] = "dict";
              tempObjectFrame.push(subObject);

              //2. *어떤 객체에서 포인터 객체(compound type)를 2개 이상 가지면 패널 하나 더 생성해서 layer를 나눠 구분시켜주는 선행작업*
              var isOverTwoCompoundCount = false; // 한 노드내에 다른 노드를 가르키는 객체가 2개 이상일때 true
              var CompoundCount = 0; // 다른 노드를 가르키는 개수

              // DICT는 key,value 2개로 이루어짐 링크가 많아봐야 1개임
              if (data[0] != "DICT") {
                for (var index in data) {
                  // var ref = data[1]
                  if (index >= 2) {
                    //compound type이면
                    if (!isPrimitive(data[index])) CompoundCount++; //개수 증가
                  }
                }
              }

              // console.log("value : "+ data[0]);
              // console.log("ref : "+ data[1]);
              // console.log("CompoundCount : "+ CompoundCount);
              // 한 노드내에서 2개 이상 자신과 같거나 다른 객체를 가지면 flag 변화
              if (CompoundCount >= 2) isOverTwoCompoundCount = true

              //2. 해당 object 값안에서 재귀로 계속 object 생성
              for (var index in data) {
                if (index >= 2) {
                  //타입 분류
                  if (data[0] == "LIST" || data[0] == "TUPLE" || data[0] == "SET") {
                    value = data[index];
                    // 한 노드내에서 2가지 이상 자신과 같거나 다른 노드가 있는 경우 + 현재 값이 compound type인 경우
                    // layer를 나누어주는 패널하나 생성해줌
                    if (isOverTwoCompoundCount && !isPrimitive(value)) {

                      object_subPanel = {}
                      object_subPanel["key"] = "subPanel_" + data[0] + "_No" + (panel_count + 1) + "_from_" + data[1];
                      object_subPanel["group"] = root_group;
                      object_subPanel["isGroup"] = true;
                      object_subPanel["category"] = "object_panel";
                      tempSubPanelFrame.push(object_subPanel);

                      isNodeType = "LIST,TUPLE,SET"
                      decode_type(value, data[1], object_subPanel["key"], false);
                      isNodeType = ""

                      panel_count++;

                    } else {
                      isNodeType = "LIST,TUPLE,SET"
                      decode_type(value, data[1], root_group, false);
                      isNodeType = ""
                    }
                    // decode_type(value, data[1], root_group, false);
                  } else if (data[0] == "DICT") {

                    key = data[index][0]
                    value = data[index][1]

                    subdict = {};
                    subdict["key"] = data[1] + "_" + key;

                    // 데이터가 중복으로 들어가지 않도록
                    if (!dict_ref.includes(subdict["key"])) {
                      dict_ref.push(subdict["key"])
                      subdict["color"] = "black"
                      subdict["group"] = "" + data[1];
                      subdict["isGroup"] = true;
                      subdict["category"] = "subdict";
                      tempObjectNode.push(subdict);

                      if (isPrimitive(value)) {
                        //python에선 null -> None으로 표현
                        if (typeof(value) === typeof("")) value = "'" + value + "'";
                        if (value == null) value = "None";
                        text = "'" + key + "' : " + value;
                        subObject = {}
                        subObject["key"] = "data_" + subdict["key"];
                        subObject["text"] = text;
                        subObject["color"] = color_list[color_index % color_list.length];
                        subObject["group"] = subdict["key"];
                        tempObjectNode.push(subObject);
                      } else {
                        //true이면 "'key' : ??" 형태로 출력하기 위함
                        isNodeType = "DICT"
                        decode_type(key, subdict["key"], root_group, true); //key는 compound type이 될수 없으니 링크없이
                        decode_type(value, subdict["key"], root_group, false);
                        isNodeType = ""
                      }
                    }
                  }
                  //함수 일때
                  else {
                    isFind = false;
                    // <function func ........> 중 func 를 가져오는 과정 -> import들은 '' 달고옴
                    func_name = data[2].split(' ')[1]
                    if (data[0] == "module") {
                      func_name = func_name.match(/\'{1}(.*){1}\'{1}/)[1]
                    } ////////불안하다잉
                    //next_button  클릭시 getStackLocalsParameter 로 저장된 parameter list
                    for (var i = 0; i < stack_parameter.length; i++) {
                      //key -> global['key'] -> 함수이름
                      if (stack_parameter[i][func_name] != null || stack_parameter[i][func_name] != undefined) {
                        value = stack_parameter[i][func_name];
                        isFind = true;
                      }
                    }
                    //못찾았으면 걍 이름() -> 못찾는 경우 = 함수가 안불렸을 때
                    if (!isFind) {
                      value = func_name + "()";
                    }
                    //함수 타입임을 알려줌
                    isNodeType = "FUNCTION";
                    decode_type(value, data[1], root_group, false);
                    isNodeType = "";
                  } //else
                } // >=2
              } //for
            } //!object_ref
          } //else
        } //func

        //type 검사
        function isPrimitive(test) {
          return (test !== Object(test));
        };

        //1_1234 형태에서 앞 쪽 기준 오름차순
        function sortAsc(a, b) {
          // a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
          // sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다.
          array1 = a.split("_")
          array2 = b.split("_")

          return array1[0] - array2[0];
        };
        //1_1234 형태에서 뒤 쪽 기준 내림차순
        function sortDesc(a, b) {
          // a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
          // sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다.
          array1 = a.split("_")
          array2 = b.split("_")


          return array2[1] - array1[1];
        };
        //1_1234 형태에서 앞 쪽 기준 오름차순
        function sortDesc2(a, b) {
          // a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
          // sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다
          array1 = a.split("_")
          array2 = b.split("_")

          return array1[1] - array2[1];
        };
        //         //스크롤 block
        //         function disableScrolling(){
        //             var x=window.scrollX;
        //             var y=window.scrollY;
        //             window.onscroll=function(){window.scrollTo(x, y);};
        //         }
        //         //스크롤 enable
        //         function enableScrolling(){
        //             window.onscroll=function(){};
        //         }

      });
    </script>
</body>

</html>
